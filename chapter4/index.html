<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>RoadMap</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      background-color: #1e272e;
      color: #f5f6fa;
    }

    main {
      max-width: 1480px;
      margin: 0 auto;
      display: flex;
      justify-content: space-between;
      gap: 20px;
      margin-top: 10px;
    }

    .row {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    fieldset.question {
      max-width: 480px;
      padding: 20px;
      border-radius: 5px;
    }

    fieldset.fieldset__answer {
      background-color: #00a8ff;
    }
    
    legend {
      font-weight: 700;
      font-size: 24px;
      background-color: #f1c40f;
      color: #1e272e;
      border-radius: 5px;
      padding: 5px 10px;
    }
    

    /* .answer {
      background-color: #00a8ff;
      border-radius: 5px;
      padding: 10px;
    } */

    p {
      color: #1e272e;
      font-weight: 600;
    }

    p.white {
      color: #f5f6fa;
    }

    code {
      color: #4cd137;
      font-size: 16px;
      white-space: pre-wrap;
    }
  </style>
</head>
<body>
  <main>
    <div class="row row1">
      <fieldset class="question fieldset__answer">
        <legend>Что такое this?</legend>
        
        <div class="answer">
          <p>this — это ссылка на какой-то объект.</p>
          <br>
          <p>this в JavaScript — это контекст вызова, то есть объект, к которому относится текущий код во время исполнения.</p>
          <br>
          <p>this в JavaScript — это ссылка на объект, в контексте которого была вызвана функция.</p>
          <br>
          <p>Значение this не определяется во время объявления функции, а только в момент её вызова. Его поведение зависит от способа вызова и режима (обычный или strict).</p>
          <br>
          <p>this — это динамически определяемая ссылка на объект, в контексте которого выполняется функция. В обычной функции зависит от способа вызова, в стрелочной — лексически унаследовано. На практике this особенно важно контролировать в методах объектов, callback'ах и при работе с class</p>
        </div>
      </fieldset>
      <fieldset class="question">
        <legend>Чему равен this в свойствах объекта?</legend>
        <p class="white">this в свойствах объекта (при его создании) не ссылается на сам объект, а берёт значение из внешнего контекста исполнения.</p>
        <pre><code>let apt = {
  address: "431 Pierson St.",
  whatIsThat: this, // <ref *1> Object [global] {...}
  subApt: {
    aptNumber: 2003,
    thisInSubApt: this, // <ref *1> Object [global] {...}
    doubleSubApt: {
      rooms: 3,
      bathrooms: 1,
      thisInDoubleSubApt: this, // <ref *1> Object [global] {...}
    }
  }
}
        </code></pre>
        <br>
        <pre><code>let person = {
  name: "TinyHzer",

  defineThis() {
    console.log(this); // {name: 'TinyHzer', ... }
  },

  defineThisArrow: () => {
    console.log(this); // <ref *1> Object [global] {...}
  },

  parameters: {
    age: 27,

    defineThis() {
      console.log(this); // {age: 27, ... }
    },

    defineThisArrow: () => {
      console.log(this); // <ref *1> Object [global] {...}
    },
    
    health: {
      bloodType: "AB-",

      defineThis() {
        console.log(this); // {bloodType: 'AB-', ... }
      },

      defineThisArrow: () => {
        console.log(this); // <ref *1> Object [global] {...}
      }
    }
  }
}</code></pre>
      </fieldset>
      <fieldset class="question">
        <legend>String(obj < 0) + String(obj < 0) // "truefalse". Как это сделать?</legend>
        <pre><code>let obj = {
  state: 0,
  [Symbol.toPrimitive]() {
    if (this.state === 0) {
      this.state++;
      return -1;
    } else {
      this.state--;
      return 1;
    }
  }
}

console.log(String(obj < 0) + String(obj < 0)); // truefalse</code></pre>
      </fieldset>
    </div>
    <div class="row row2">
      <fieldset class="question">
        <legend>Как потерять this?</legend>
        <pre><code>let user = {
  name: "John",
  sayHi() {
    alert(this.name);
  }
};

let f = user.sayHi;
f(); // undefined</code></pre>
        <br>
        <br>
        <pre><code>function invokeCallback(cb) { // здесь мы «декларируем» параметр cb
  cb(); // а здесь — вызываем его как функцию
}

let user = {
  name: "Вася",
  sayHi() {
    console.log(this.name);
  }
};

invokeCallback(user.sayHi);// передали метод как колбэк → потеряли this → undefined</code></pre>
      </fieldset>
      <fieldset class="question fieldset__answer">
        <legend>Чему равен this в геттерах/сеттерах объекта?</legend>
        <p>getters & setters - функции и каких-то явных особенностей поведения this в них нет</p>
      </fieldset>
      <fieldset class="question">
        <legend>Чему равен this внутри функции-стрелки?</legend>
        <p class="white">наследует this из внешнего лексического окружения</p>
        <br>
        <p class="white">оно захватывается (лексически) из окружения, где стрелка была определена, а не вызвана</p>
        <br>
        <p class="white">this внутри стрелки = this внешней функции/контекста, где она была создана.</p>
        <pre><code>let obj = {
  id: 42,
  regular() {
    let arrow = () => console.log(this.id);
    arrow();
  }
};
obj.regular(); // 42
// → стрелка унаследовала this = obj из метода regular</code></pre>
        <br>
        <pre><code>function foo() {
  this.value = 7;
  let arrow = () => console.log(this.value);
  arrow();
}
foo.call({ value: 99 }); // 99
// → стрелка захватила this = { value: 99 }</code></pre>
      </fieldset>
      <fieldset class="question">
        <legend>obj > 0 // true. Как это сделать?</legend>
        <p class="white">Операторы сравнения (>, <, <=, >=) всегда используют хинт "number", и пытаются получить число из объекта.</p>
        <pre><code>const obj = {
  [Symbol.toPrimitive](hint) {
    return hint === "number" ? 1 : "ignored";
  }
};

console.log(obj > 0); // true</code></pre><br>
        <pre><code>const obj = {
  valueOf() {
    return 1;
  }
};

console.log(obj > 0); // true</code></pre>

      </fieldset>
      <fieldset class="question">
        <legend>Что происходит внутри при вызове функции-конструктора с new?</legend>
        <pre><code>function User(name) {
  // this = {};  (неявно)

  // добавляет свойства к this
  this.name = name;
  this.isAdmin = false;

  // return this;  (неявно)
}</code></pre>
      </fieldset>
    </div>
    <div class="row row3">
      <fieldset class="question">
        <legend>Как не терять this?</legend>
        <p class="white">1. .bind() Привязывает this жёстко к объекту:</p>
        <pre><code>let f = user.sayHi.bind(user);
f(); // this === user</code></pre>
        <br>
        <p class="white">2. Обёртка-стрелка – берёт this из лексического окружения</p>
        <p class="white">Стрелочные функции не имеют своего this, поэтому он захватывается из внешнего скоупа:</p>
        <pre><code>let user = {
  name: "Вася",
  sayHi() {
    console.log(this.name);
  }
};

function invoke(cb) {
  cb(); // простой вызов, без привязки
}

invoke(() => user.sayHi()); // Вася</code></pre>
        <br>
        <p class="white">3. call / apply – однократный вызов с явной передачей this</p>
        <p class="white">Если вы контролируете место вызова, можно прямо передать контекст:</p>
        <pre><code>let user = { name: "Вася", sayHi() { console.log(this.name); } };

// внутри другой функции:
function exec(callback) {
  // вместо callback(), делаем:
  callback.call(user);    // <- this = user
}

exec(user.sayHi); // Вася</code></pre>
        <br>
        <p class="white">4. Методы‑стрелки в классах или в литеральном объекте (через class‑fields)</p>
        <p class="white">При объявлении метода как стрелочного поля он «навсегда» привязан к экземпляру:</p>
        <pre><code>class User {
  name = "Вася";
  sayHi = () => {
    console.log(this.name);
  }
}

let u = new User();
let fn = u.sayHi;
fn(); // Вася</code></pre>
      </fieldset>
      <fieldset class="question">
        <legend>Как сделать, чтобы объект был равен определенному числу?</legend>
        <pre><code>const obj = {
  [Symbol.toPrimitive]() {
    return 123;
  }
};

console.log(obj == 123); // true</code></pre>
        <br>
        <pre><code>const obj = {
  valueOf() {
    return 123;
  }
};

console.log(obj == 123); // true</code></pre>
      </fieldset>
      <fieldset class="question">
        <legend>Как сделать, чтобы объект был равен определенной строке?</legend>
        <pre><code>const obj = {
  toString() {
    return "hello";
  }
};

console.log(obj == "hello"); // true</code></pre><br>
        <pre><code>const obj = {
  [Symbol.toPrimitive](hint) {
    return hint === "string" || hint === "default" ? "hello" : 0;
  }
};

console.log(obj == "hello"); // true</code></pre>
      </fieldset>
      <fieldset class="question">
        <legend>Можно ли вызвать конструктор без new? Что будет?</legend>
        <p class="white">Если вызвать конструктор без new, то внутри функции this будет:</p>
        <p class="white">1. В строгом режиме ('use strict') — undefined, что обычно приводит к ошибке при попытке обратиться к свойствам this.</p>
        <p class="white">2. В нестрогом режиме — this будет указывать на глобальный объект (window в браузере), и свойства будут добавлены туда — что почти всегда баг.</p>
      </fieldset>
    </div>
  </main>
</body>
</html>